<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>leetcode Experience | Wade</title><meta name="author" content="Wade Kao"><meta name="copyright" content="Wade Kao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="紀錄程式自我學習">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode Experience">
<meta property="og:url" content="https://wadewei0307.github.io/2022/11/02/leetcode-Experience/index.html">
<meta property="og:site_name" content="Wade">
<meta property="og:description" content="紀錄程式自我學習">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://wadewei0307.github.io/image/leetcode-Experience/leetcode_coverImg.png">
<meta property="article:published_time" content="2022-11-01T19:18:00.000Z">
<meta property="article:modified_time" content="2023-05-10T14:12:47.202Z">
<meta property="article:author" content="Wade Kao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wadewei0307.github.io/image/leetcode-Experience/leetcode_coverImg.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://wadewei0307.github.io/2022/11/02/leetcode-Experience/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'leetcode Experience',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-10 14:12:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/config.butterfly/Apple_logo_black.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/image/leetcode-Experience/leetcode_coverImg.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Wade"><span class="site-name">Wade</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">leetcode Experience</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-11-01T19:18:00.000Z" title="Created 2022-11-01 19:18:00">2022-11-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-05-10T14:12:47.202Z" title="Updated 2023-05-10 14:12:47">2023-05-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Code-Training/">Code Training</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Code-Training/LeetCode/">LeetCode</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="leetcode Experience"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Easy-Part"><a href="#Easy-Part" class="headerlink" title="Easy Part"></a>Easy Part</h1><h2 id="Array-相關問題"><a href="#Array-相關問題" class="headerlink" title="Array 相關問題"></a>Array 相關問題</h2><h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h3><ul>
<li><font color="red"> 題目：</font>給定一個vector nums和一個int target，必須在vector內的元素找到兩個相加等於target的位置。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,7,11,15], target = 9</span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3,2,4], target = 6</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>將與target的差值存進Hash table內，若vector內的元素有在Hash table則代表找到兩個元素的位置。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leetcode_1::twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; diffIndx; <span class="comment">//&#123;nums[i], i&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!diffIndx.<span class="built_in">count</span>(target - nums[i])) <span class="comment">//judge whether (target - nums[i]) is in diffIndx or not</span></span><br><span class="line">            diffIndx[nums[i]] = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> &#123; diffIndx[target - nums[i]], i &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">0</span>, <span class="number">0</span> &#125;; <span class="comment">//if find no any combination</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>走訪一次nums，所以O(n)。<br></li>
</ul>
<h3 id="Q26"><a href="#Q26" class="headerlink" title="Q26"></a>Q26</h3><ul>
<li><font color="red"> 題目：</font>給一個non-decreasing order的 vector nums，要移除相同的元素，並回傳剩餘元素的個數。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,1,2]</span><br><span class="line">Output: 2, nums = [1,2,_]</span><br><span class="line">Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]</span><br><span class="line">Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>因為是non-decreasing order，所以只要下一個value大於原先的value，則表示沒重複，並且把下一個的位置記下來(finalSize)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">leetcode_26::removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> finalSize = <span class="number">1</span>; <span class="comment">//return finally size</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123; <span class="comment">//because is sorted array, so can use &gt;</span></span><br><span class="line">            nums[finalSize] = nums[i]; <span class="comment">//record the finalSize and value of finalSize</span></span><br><span class="line">            ++finalSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> finalSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>走訪一次nums，所以O(n)。<br></li>
</ul>
<h3 id="Q27"><a href="#Q27" class="headerlink" title="Q27"></a>Q27</h3><ul>
<li><font color="red"> 題目：</font>給定一個陣列，必須在同一個陣列內移除相同的元素，並且回傳陣列內剩餘的個數。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-element/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3,2,2,3], val = 3 </span><br><span class="line">Output: 2, nums = [2,2,_,_] </span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">Output: 5, nums = [0,1,4,0,3,_,_,_]</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>若遇到陣列內元素與val相等則刪除，且陣列長度同時-1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">leetcode_27::removeElement_27</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">            nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>() + i);</span><br><span class="line">            --i; <span class="comment">//刪掉一個長度會-1，所以也要讓index-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>走訪一次nums，所以O(n)。<br></li>
</ul>
<h3 id="Q35"><a href="#Q35" class="headerlink" title="Q35"></a>Q35</h3><ul>
<li><font color="red"> 題目：</font>給一個vector nums和一個int target，必須找到target要在排序好的nums的哪個位置。<br><br>特殊要求：必須在O(log(n))完成。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-insert-position/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,3,5,6], target = 5</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,3,5,6], target = 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,3,5,6], target = 7</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>因為必須在O(log(n))完成，所以必須用binary search達成。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">leetcode_35::searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123; <span class="comment">//O(log(n)) need to use binary search</span></span><br><span class="line">        mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>binary search，所以O(log(n))。<br></li>
</ul>
<h3 id="Q66"><a href="#Q66" class="headerlink" title="Q66"></a>Q66</h3><ul>
<li><font color="red"> 題目：</font>給一個vector digits，必須把裡頭的元素當成int加1。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/plus-one/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: digits = [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br><span class="line">Incrementing by one gives 123 + 1 = 124.</span><br><span class="line">Thus, the result should be [1,2,4].</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: digits = [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br><span class="line">Incrementing by one gives 4321 + 1 = 4322.</span><br><span class="line">Thus, the result should be [4,3,2,2].</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: digits = [9]</span><br><span class="line">Output: [1,0]</span><br><span class="line">Explanation: The array represents the integer 9.</span><br><span class="line">Incrementing by one gives 9 + 1 = 10.</span><br><span class="line">Thus, the result should be [1,0].</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>利用carryBit判斷是否有進位，分成兩種情形：<br></li>
</ul>
<ol>
<li>如果某位數不是9，則carryBit清成False(避免在迴圈外又再最大位數insert一個1)，並且跳出迴圈。<br></li>
<li>如果全部都是9，則在跳出迴圈時，必須在最大位數insert一個1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leetcode_66::plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> carryBit = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = digits.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == digits.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; digits[i] == <span class="number">9</span>) &#123; <span class="comment">//個位數是9</span></span><br><span class="line">            carryBit = <span class="literal">true</span>;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (digits[i] == <span class="number">9</span> &amp;&amp; carryBit) &#123; <span class="comment">//十位數以上有9且有進位</span></span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            carryBit = <span class="literal">false</span>; <span class="comment">//避免該位數不是9的時候又在後面digits.insert </span></span><br><span class="line">            digits[i] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carryBit) <span class="comment">//表示前面全部都是9</span></span><br><span class="line">        digits.<span class="built_in">insert</span>(digits.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">時間複雜度：</font>走訪一次digits，所以O(n)。<br></li>
</ul>
<h3 id="Q88"><a href="#Q88" class="headerlink" title="Q88"></a>Q88</h3><ul>
<li><font color="red"> 題目：</font>給vector nums1及該vector實際上有value的個數m，以及vector nums2及該vector實際上有value的個數n(也等於nums2.size())，必須將兩個vector合併且是non-decreasing order vector。<br><br>特殊要求：不得宣告其餘空間，只能回傳nums1。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-sorted-array/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">Output: [1,2,2,3,5,6]</span><br><span class="line">Explanation: The arrays we are merging are [1,2,3] and [2,5,6].</span><br><span class="line">The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: The arrays we are merging are [1] and [].</span><br><span class="line">The result of the merge is [1].</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [0], m = 0, nums2 = [1], n = 1</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: The arrays we are merging are [] and [1].</span><br><span class="line">The result of the merge is [1].</span><br><span class="line">Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font><br></li>
</ul>
<ol>
<li>將nums2最大的元素與nums1最大的元素開始比，若nums2大，則將nums2放在最後一個；反之則將nums1的放在最後一個，以此類推。</li>
<li>當然也可以直接將nums2先放在nums1後面，然後再sort。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">leetcode_88::merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = nums1.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) &#123; <span class="comment">//nums1 is empty</span></span><br><span class="line">        nums1 = nums2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (m &gt; <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span>) &#123; <span class="comment">//nums1 or nums2都還有Element還沒比完的時候</span></span><br><span class="line">            <span class="keyword">if</span> (nums2[n - <span class="number">1</span>] &gt; nums1[m - <span class="number">1</span>]) &#123; <span class="comment">//當nums2的元素比nums1的元素大，把nums2的元素往後擺在nums1的後面</span></span><br><span class="line">                nums1[i] = nums2[n - <span class="number">1</span>];</span><br><span class="line">                --i;</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//當nums1的元素比nums2的大，把nums1的元素往後擺</span></span><br><span class="line">                nums1[i] = nums1[m - <span class="number">1</span>];</span><br><span class="line">                --i;</span><br><span class="line">                --m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">//若nums2全部元素都比nums1最小的還小的時候</span></span><br><span class="line">        nums1[j] = nums2[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">時間複雜度：</font><br></li>
</ul>
<ol>
<li>若為想法1，則為走訪一個nums1 or nums2，所以為O(n)。<br></li>
<li>若為想法2，則最快的排序只能到達O(log(n))。<br></li>
</ol>
<h3 id="Q108"><a href="#Q108" class="headerlink" title="Q108"></a>Q108</h3><ul>
<li><font color="red"> 題目：</font>將給定的vector nums1轉成binary tree。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br><span class="line">Explanation: [0,-10,5,null,-3,null,9] is also accepted:</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,3]</span><br><span class="line">Output: [3,1]</span><br><span class="line">Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font> 利用binary search以及遞迴的方式將左子樹和右子樹建立起來。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TreeNode</span>(): <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode* left, TreeNode* right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">TreeNode* <span class="title">leetcode_108::sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">binarySearch</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">leetcode_108::binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">    <span class="type">int</span> mid = (start + end) / <span class="number">2</span> ;</span><br><span class="line">    root-&gt;val = nums[mid];</span><br><span class="line">    root-&gt;left = <span class="built_in">binarySearch</span>(nums, start, mid<span class="number">-1</span>);</span><br><span class="line">    root-&gt;right = <span class="built_in">binarySearch</span>(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>每個binarySearch function為O(log(n))，nums裡的每個元素都會走一次binarySearch function，所以為O(nlog(n))。</li>
</ul>
<h3 id="Q118"><a href="#Q118" class="headerlink" title="Q118"></a>Q118</h3><ul>
<li><font color="red"> 題目：</font>給一個整數n，回傳巴斯卡三角形前n層所有組合。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/pascals-triangle/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numRows = 5</span><br><span class="line">Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numRows = 1</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>a[n][n] &#x3D; a[n-1][n-1] + a[n-1][n]。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; leetcode_118::<span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">    <span class="type">int</span> hypotenuse = <span class="number">1</span>; <span class="comment">//斜邊</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tempAns;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> level = <span class="number">1</span>; level &lt;= numRows; level++) &#123;</span><br><span class="line">        <span class="type">int</span> lastestIndex = level - <span class="number">1</span>; <span class="comment">//該層最後一個Index</span></span><br><span class="line">        <span class="type">int</span> preLevel = level - <span class="number">2</span>; <span class="comment">//前一層的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> indexOfLevel = <span class="number">0</span>; indexOfLevel &lt; level; indexOfLevel++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indexOfLevel == <span class="number">0</span> || indexOfLevel == lastestIndex) <span class="comment">//如果是第一個Index或當前Level的最後一個Index</span></span><br><span class="line">                tempAns.<span class="built_in">push_back</span>(hypotenuse);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> exIndex = indexOfLevel - <span class="number">1</span>; <span class="comment">//記錄前一個Index</span></span><br><span class="line">                tempAns.<span class="built_in">push_back</span>(ans[preLevel][exIndex] + ans[preLevel][indexOfLevel]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(tempAns);</span><br><span class="line">        tempAns.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>每個level遍歷所有元素一次，故O(n<sup>2</sup>)。</li>
</ul>
<h3 id="Q119"><a href="#Q119" class="headerlink" title="Q119"></a>Q119</h3><ul>
<li><font color="red"> 題目：</font>給一個整數n，回傳巴斯卡三角形第n層的組合。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/pascals-triangle-ii/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: rowIndex = 3</span><br><span class="line">Output: [1,3,3,1]</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: rowIndex = 0</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>
3.<br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: rowIndex = 1</span><br><span class="line">Output: [1,1]</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>如註解所示。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leetcode_119::getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line"><span class="comment">//           n!</span></span><br><span class="line"><span class="comment">// nCr = -----------</span></span><br><span class="line"><span class="comment">//        r!.(n-r)!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//                  n!</span></span><br><span class="line"><span class="comment">// nC(r-1) = -----------------</span></span><br><span class="line"><span class="comment">//            (r-1)!.(n-r+1)!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//                     n!        (r-1)!x(n-r+1)!</span></span><br><span class="line"><span class="comment">// nCr / nC(r-1) = ----------- x ---------------</span></span><br><span class="line"><span class="comment">//                  r!.(n-r)!          n!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//                 (n-r+1)</span></span><br><span class="line"><span class="comment">//               = -------</span></span><br><span class="line"><span class="comment">//                    r</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nC0 = 1</span></span><br><span class="line"><span class="comment">// nCr = nC(r-1) x (n-r+1) / r</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(rowIndex + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; rowIndex; i++) &#123;</span><br><span class="line">        temp = temp * (rowIndex - i + <span class="number">1</span>) / i;</span><br><span class="line">        ans[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>只需把第n層的每個係數算出來，所以O(n)。</li>
</ul>
<h3 id="Q121"><a href="#Q121" class="headerlink" title="Q121"></a>Q121</h3><ul>
<li><font color="red"> 題目：</font>給一個vector，n個元素表示n日的股價，算出最大的收益<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</span><br><span class="line">Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transactions are done and the max profit = 0.</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>每遍歷一次元素便判斷是否為最低點，若不是則計算一次收益，若是最低點則替換掉原先的最低點且不必計算收益。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">leetcode_121::maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> profit = <span class="number">0</span>; <span class="comment">//最後收益</span></span><br><span class="line">    <span class="type">int</span> tmpProfit = <span class="number">0</span>; <span class="comment">//算暫時的收益</span></span><br><span class="line">    <span class="type">int</span> lowest = prices[<span class="number">0</span>]; <span class="comment">// 最低點</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt;= lowest) &#123; <span class="comment">//如果比最低點大，算一次收益</span></span><br><span class="line">            tmpProfit = prices[i] - lowest;</span><br><span class="line">            <span class="keyword">if</span> (tmpProfit &gt; profit) &#123; <span class="comment">//如果此次收益比原本的收益大，取代掉</span></span><br><span class="line">                profit = tmpProfit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//此次為更低點</span></span><br><span class="line">            lowest = prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>遍歷每天的股價，所以O(n)。</li>
</ul>
<h3 id="Q136"><a href="#Q136" class="headerlink" title="Q136"></a>Q136</h3><ul>
<li><font color="red"> 題目：</font>給一段vector，判斷只出現過一次的元素，其餘皆剛好出現兩次<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/single-number/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>因為其餘元素剛好只出現過兩次，所以可以利用XOR(互斥或)。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">leetcode_136::singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        ans = ans ^ nums[i]; <span class="comment">//因為重複的元素只會出現兩次，所以可以用互斥或</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>遍歷每個元素，所以O(n)。</li>
</ul>
<h3 id="Q169"><a href="#Q169" class="headerlink" title="Q169"></a>Q169</h3><ul>
<li><font color="red"> 題目：</font>給一段vector，找出出現最多次的元素<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/majority-element/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,2,1,1,1,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>出現過最多次的元素一定會&gt;&#x3D;長度的一半。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">leetcode_169::majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">//數數字出現幾次</span></span><br><span class="line">        <span class="type">int</span> majority = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; <span class="comment">//因為majority一定&gt;=nums.size()/2，所以減到最後一定剩下majority</span></span><br><span class="line">            <span class="keyword">if</span> (majority == nums[i])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                count--;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123; <span class="comment">//count被扣成0換人當majority</span></span><br><span class="line">                majority = nums[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>遍歷每個元素，所以O(n)。</li>
</ul>
<h3 id="Q217"><a href="#Q217" class="headerlink" title="Q217"></a>Q217</h3><ul>
<li><font color="red"> 題目：</font>給一段vector，如果有出現重複則回傳TRUE，反之則FALSE。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/contains-duplicate/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>利用hash table的library -&gt; count()。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">leetcode_217::containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; existElement; <span class="comment">//紀錄是否出現過</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!existElement.<span class="built_in">count</span>(nums[i]))</span><br><span class="line">            existElement[nums[i]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>遍歷每個元素，且Hash table搜尋為O(1)，所以O(n)。</li>
</ul>
<h3 id="Q219"><a href="#Q219" class="headerlink" title="Q219"></a>Q219</h3><ul>
<li><font color="red"> 題目：</font>給一段vector，如果有出現重複且兩個元素所在的位置其距離小於等於整數K，若存在多個重負責取距離最短的，則回傳TRUE；反之則FALSE。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/contains-duplicate-ii/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,1], k = 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,0,1,1], k = 1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,1,2,3], k = 2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>利用hash table記住元素以及其位置。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">leetcode_219::containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; elementIndex; <span class="comment">//記得元素的位置</span></span><br><span class="line">    <span class="type">int</span> lengthOfElement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!elementIndex.<span class="built_in">count</span>(nums[i]))</span><br><span class="line">            elementIndex[nums[i]] = i;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//若存在此元素，則計算兩個重複的元素距離</span></span><br><span class="line">            lengthOfElement = i - elementIndex[nums[i]];</span><br><span class="line">            elementIndex[nums[i]] = i;</span><br><span class="line">            <span class="keyword">if</span> (k &gt;= lengthOfElement)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>遍歷每個元素，且Hash table搜尋為O(1)，所以O(n)。</li>
</ul>
<h3 id="Q228"><a href="#Q228" class="headerlink" title="Q228"></a>Q228</h3><ul>
<li><font color="red"> 題目：</font>給一段vector，每個數字只會出現一次，若連續的數字則整理成”a-&gt;b”，若單獨出現則整理成”a”。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/summary-ranges/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [0,1,2,4,5,7]</span><br><span class="line">Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">Explanation: The ranges are:</span><br><span class="line">[0,2] --&gt; &quot;0-&gt;2&quot;</span><br><span class="line">[4,5] --&gt; &quot;4-&gt;5&quot;</span><br><span class="line">[7,7] --&gt; &quot;7&quot;</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [0,2,3,4,6,8,9]</span><br><span class="line">Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">Explanation: The ranges are:</span><br><span class="line">[0,0] --&gt; &quot;0&quot;</span><br><span class="line">[2,4] --&gt; &quot;2-&gt;4&quot;</span><br><span class="line">[6,6] --&gt; &quot;6&quot;</span><br><span class="line">[8,9] --&gt; &quot;8-&gt;9&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>跟題目所述一樣。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">leetcode_228::summaryRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="type">int</span> startIndex = <span class="number">0</span>; <span class="comment">//記住每一次的起點</span></span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">1</span>) <span class="comment">//若nums沒有任何的元素</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == nums.<span class="built_in">size</span>() - <span class="number">1</span> || nums[i] + <span class="number">1</span> != nums[i + <span class="number">1</span>]) &#123; <span class="comment">//處理是最後一個元素的時候無條件進入；在不是最後一個元素時判斷前一個跟下一個不是連續的元素</span></span><br><span class="line">            <span class="keyword">if</span> (i - startIndex &gt; <span class="number">0</span>) &#123; <span class="comment">//起點跟終點有至少1個數量以上的元素</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[startIndex]) + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(nums[i]));</span><br><span class="line">                startIndex = i + <span class="number">1</span>; <span class="comment">//將起點移至終點的下一個元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//起點跟終點是同一個元素</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[startIndex]));</span><br><span class="line">                startIndex = i + <span class="number">1</span>; <span class="comment">//將起點移至終點的下一個元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>遍歷每個元素，所以O(n)。</li>
</ul>
<h3 id="Q268"><a href="#Q268" class="headerlink" title="Q268"></a>Q268</h3><ul>
<li><font color="red"> 題目：</font>給一vector的整數，找出少掉的數字。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/missing-number/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3,0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [9,6,4,2,3,5,7,0,1]</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>先將Range內的所有數字加總，再減去input vector內的數字加總。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">leetcode_268::missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> totalCount = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    ans = ((<span class="number">0</span> + totalCount) * (totalCount<span class="number">-0</span>+<span class="number">1</span>)) / <span class="number">2</span>; <span class="comment">//先總和nums長度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; </span><br><span class="line">        ans -= nums[i]; <span class="comment">//再減去nums裡面的所有元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>遍歷每個元素，所以O(n)。</li>
</ul>
<h3 id="Q283"><a href="#Q283" class="headerlink" title="Q283"></a>Q283</h3><ul>
<li><font color="red"> 題目：</font>給一vector排序好的整數，最後將0移到vector後方。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/move-zeroes/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0]</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>遇到非0的元素則跟第0的index元素交換，並且將index移到1。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">leetcode_283::moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lastNonZero = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//遇到不為0的從前面第一個開始放，並且記錄最後一個不為0的位置</span></span><br><span class="line">            nums[lastNonZero++] = nums[i]; <span class="comment">//這裡也可以用交換的，如此一來就不用再用後面的迴圈把0補上去 swap(nums[lastNonzero], nums[i]); lastNonzero++;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = lastNonZero; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; <span class="comment">//從不為0的位置開始後面都放0</span></span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>遍歷每個元素，所以O(n)。</li>
</ul>
<h3 id="Q303"><a href="#Q303" class="headerlink" title="Q303"></a>Q303</h3><ul>
<li><font color="red"> 題目：</font>給一vector整數，且input left跟right，回傳sum(left,right)這個範圍內的總合。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/range-sum-query-immutable/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]</span><br><span class="line">[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</span><br><span class="line">Output</span><br><span class="line">[null, 1, -1, -3]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);</span><br><span class="line">numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1</span><br><span class="line">numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1</span><br><span class="line">numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>先將資料處理好，a[0]為前0個元素的總和，a[1]為前1個元素的總和，以此類推。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">leetcode_303</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmpAns;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">leetcode_303</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        tmpAns.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>(), nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; <span class="comment">//tmpAns存放累加值</span></span><br><span class="line">            tmpAns[i] = nums[i]+tmpAns[i<span class="number">-1</span>]; <span class="comment">//當下的值+前面的累加值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">leetcode_303::sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left == <span class="number">0</span> ? tmpAns[right]:tmpAns[right] - tmpAns[left<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>因為資料已經事先處理好，所以在回傳總和時可以達到O(1)。</li>
</ul>
<h3 id="Q349"><a href="#Q349" class="headerlink" title="Q349"></a>Q349</h3><ul>
<li><font color="red"> 題目：</font>給兩個vector整數，找出兩個vector出現過一樣的整數。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-arrays/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">Output: [9,4]</span><br><span class="line">Explanation: [4,9] is also accepted.</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>利用Hash table紀錄每個元素是否出現過，再去與第二個vector做比對。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leetcode_349::intersect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; elementExist;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123; <span class="comment">//將nums1出現過的元素存進hash table並設成TRUE</span></span><br><span class="line">        <span class="keyword">if</span> (!elementExist.<span class="built_in">count</span>(nums1[i]))</span><br><span class="line">            elementExist[nums1[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); i++) &#123; <span class="comment">//將nums2曾經出現在nums1的元素推進ans，並且只推一次</span></span><br><span class="line">        <span class="keyword">if</span> (elementExist[nums2[i]]) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(nums2[i]);</span><br><span class="line">            elementExist[nums2[i]] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>遍歷兩個vector各一次，所以O(n)。</li>
</ul>
<h3 id="Q350"><a href="#Q350" class="headerlink" title="Q350"></a>Q350</h3><ul>
<li><font color="red"> 題目：</font>給兩個vector整數，找出兩個vector出現一樣多次的整數。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-arrays-ii/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">Output: [2,2]</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">Output: [4,9]</span><br><span class="line">Explanation: [9,4] is also accepted.</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>利用Hash table紀錄每個元素出現的次數，再去與第二個vector做比對。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leetcode_350::intersect_2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m; <span class="comment">//用來記錄nums1元素個出現幾次</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123; <span class="comment">//將nums1的出現個數記錄在m</span></span><br><span class="line">        <span class="keyword">if</span> (!m.<span class="built_in">count</span>(nums1[i]))</span><br><span class="line">            m[nums1[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            m[nums1[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); i++) &#123; <span class="comment">//用nums2的個數去比對m裡面的出現次數</span></span><br><span class="line">        <span class="keyword">if</span> (m.<span class="built_in">count</span>(nums2[i]) &amp;&amp; m[nums2[i]] &gt; <span class="number">0</span>) &#123; <span class="comment">//若nums2在m裡出現且次數&gt;0</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(nums2[i]);</span><br><span class="line">            m[nums2[i]]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>遍歷兩個vector各一次，所以O(n)。</li>
</ul>
<h3 id="Q448"><a href="#Q448" class="headerlink" title="Q448"></a>Q448</h3><ul>
<li><font color="red"> 題目：</font>給一個1-n長的vector，找出1-n沒出現過的數字<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,3,2,7,8,2,3,1]</span><br><span class="line">Output: [5,6]</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,1]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font></li>
</ul>
<ol>
<li>可利用set，將出現過的數字存入set，再利用set跑1-n的迴圈判斷1-n誰沒出現過。<font color="orange">(時間較慢)</font></li>
<li>利用兩個vector <font color="orange">速度較快</font>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leetcode_448::findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vote</span><span class="params">(nums.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>; <span class="comment">//因為需要1~nums.size的空間，所以需要+1</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; <span class="comment">//將出現過的數字n於vote的第n個位置變成TRUE</span></span><br><span class="line">        <span class="keyword">if</span> (!vote[nums[i]])</span><br><span class="line">            vote[nums[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>(); i++) &#123; <span class="comment">//從1~nums.size找出vote為false的位置</span></span><br><span class="line">        <span class="keyword">if</span> (!vote[i])</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">時間複雜度：</font>遍歷nums vector一次以及vote vector一次，所以O(n)。</li>
</ul>
<h3 id="Q463"><a href="#Q463" class="headerlink" title="Q463"></a>Q463</h3><ul>
<li><font color="red"> 題目：</font>找出圍起來的陸地的周長。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/island-perimeter/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br><img src="/2022/11/02/leetcode-Experience/leet_463.PNG" class="" title="leetcode 463 image"></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]</span><br><span class="line">Output: 16</span><br><span class="line">Explanation: The perimeter is the 16 yellow stripes in the image above.</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,0]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>row major遍歷二維vector，若出現前後陸地，則總周長要-2；反之column major的時候也一樣，因為前一個陸地被重複算了一次，且下一個連著的陸地也被重複算一次周長。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">leetcode_463::islandPerimeter</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> totalDuplicateSide = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> xDuplicateSide;</span><br><span class="line">    <span class="type">int</span> yDuplicateSide;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i++) &#123; <span class="comment">//row major遍歷二維vector</span></span><br><span class="line">        xDuplicateSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123; <span class="comment">//因為有可能第0行有陸地，且必須列入計算周長+4</span></span><br><span class="line">                <span class="type">int</span> preY = j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; grid[i][preY] == <span class="number">1</span>) &#123;<span class="comment">//如果此塊為陸地，且其前一行也為陸地</span></span><br><span class="line">                    ans += <span class="number">4</span>;</span><br><span class="line">                    xDuplicateSide += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    ans += <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                ans += <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (xDuplicateSide &gt; <span class="number">0</span>) <span class="comment">//減去row major連續出現陸地的次數*2</span></span><br><span class="line">            ans -= xDuplicateSide * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123; <span class="comment">//column major遍歷二維vector</span></span><br><span class="line">        yDuplicateSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; grid.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="type">int</span> preX = j<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (grid[j][i] == <span class="number">1</span> &amp;&amp; grid[preX][i] == <span class="number">1</span>) &#123;<span class="comment">//如果此塊為陸地，且其前一列也為陸地</span></span><br><span class="line">                yDuplicateSide += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (yDuplicateSide &gt; <span class="number">0</span>) <span class="comment">//減去column major連續出現陸地的次數*2</span></span><br><span class="line">            ans -= yDuplicateSide * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>遍歷兩次二維vector，所以O(n<sup>2</sup>)。</li>
</ul>
<h1 id="Medium-Part"><a href="#Medium-Part" class="headerlink" title="Medium Part"></a>Medium Part</h1><h2 id="Array-相關問題-1"><a href="#Array-相關問題-1" class="headerlink" title="Array 相關問題"></a>Array 相關問題</h2><h3 id="Q11"><a href="#Q11" class="headerlink" title="Q11"></a>Q11</h3><ul>
<li><font color="red"> 題目：</font>給一個vector整數表示數根柱子，找出可以裝出最多水的體積。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/container-with-most-water/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br><img src="/2022/11/02/leetcode-Experience/leet_11.PNG" class="" title="leetcode 11 image"></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height = [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br><span class="line">Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: height = [1,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>從前面及後面同時進行，每次找短的柱子算一次面積，並且由短的柱子那邊向前或向後找下一根柱子。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">leetcode_11::maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> width = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tmpArea;</span><br><span class="line">    <span class="keyword">if</span> (height.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="comment">//沒有兩根柱子以上</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (end &gt; start) &#123; <span class="comment">//直到兩根重疊</span></span><br><span class="line">        <span class="keyword">if</span> (height[start] &gt; height[end]) &#123; <span class="comment">//取短的那根當長</span></span><br><span class="line">            tmpArea = height[end] * width;</span><br><span class="line">            end--; <span class="comment">//短的那邊往前找更長的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//取短的那根當長</span></span><br><span class="line">            tmpArea = height[start] * width;</span><br><span class="line">            start++; <span class="comment">//短的那邊往後找更長的</span></span><br><span class="line">        &#125;</span><br><span class="line">        width--;</span><br><span class="line">        <span class="keyword">if</span> (tmpArea &gt; ans)</span><br><span class="line">            ans = tmpArea;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>幾乎都是要遍歷全部柱子，所以O(n)。</li>
</ul>
<h3 id="Q49"><a href="#Q49" class="headerlink" title="Q49"></a>Q49</h3><ul>
<li><font color="red"> 題目：</font>給一個vector字串，將裡面的字元全部一樣的字串分成一組。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/group-anagrams/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs = [&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]</span><br><span class="line">Output: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs = [&quot;&quot;]</span><br><span class="line">Output: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs = [&quot;a&quot;]</span><br><span class="line">Output: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>先將字串排序，確保不管遇到什麼順序的字母都會唯一存在，將出現過的存進hash table，並設為group 1，因為唯一存在，所以下個出現不一樣的字串一定與其他不一樣，所以設為group 2，以此類推。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; leetcode_49::<span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> group = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        s = strs[i];</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>()); <span class="comment">//對字串排序，ex: eat -&gt; aet</span></span><br><span class="line">        <span class="keyword">if</span> (!m.<span class="built_in">count</span>(s)) &#123; </span><br><span class="line">            m[s] = group++; <span class="comment">//因為排序後，所以找到的字串不管怎麼交換順序一定不一樣</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123; strs[i] &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            ans[m[s]].<span class="built_in">push_back</span>(strs[i]); <span class="comment">//找到排序後重複的，直接取value值，看它屬於哪個group</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>sort為O(nlogn)，再加上遍歷strs一遍O(n)，所以O(n<sup>2</sup>logn)。</li>
</ul>
<h3 id="Q122"><a href="#Q122" class="headerlink" title="Q122"></a>Q122</h3><ul>
<li><font color="red"> 題目：</font>給一個vector整數當作每天的股價，在這幾天內得到最大的收益。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.</span><br><span class="line">Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</span><br><span class="line">Total profit is 4 + 3 = 7.</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</span><br><span class="line">Total profit is 4.</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>透過累加的方式將小收益變成總收益。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">leetcode_122::maxProfit2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) <span class="comment">//只需要計算下一天比前一天大的收益並且累加起來，也會是最大的收益</span></span><br><span class="line">            profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>遍歷一次vector完成，所以O(n)。</li>
</ul>
<h3 id="Q137"><a href="#Q137" class="headerlink" title="Q137"></a>Q137</h3><ul>
<li><font color="red"> 題目：</font>給一個vector整數，且每個整數都剛好出現3次，除了一個獨立的數字只出現一次，要找出此獨立的數字。<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/single-number-ii/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,2,3,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [0,1,0,1,0,1,99]</span><br><span class="line">Output: 99</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font>統計每個bit為1的個數，若不為3的倍數，則表示獨立的數字該bit也為1；不用考慮bit為0的情況，因為就算count為0，也會被3整除。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">leetcode_137::singleNumber2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shift = <span class="number">1</span>; <span class="comment">//用來判定每個bit是1是0</span></span><br><span class="line">    <span class="type">int</span> count; <span class="comment">//用來記錄有幾個數字該bit為1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ans = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123; <span class="comment">//32個bits</span></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &amp; shift) <span class="comment">//判斷該bit是否為1</span></span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">3</span> != <span class="number">0</span>) &#123;<span class="comment">//如果count為0，表示每個num該bit都是0，也會被整除；如果沒被3整除，則表示獨立的數字該bit為1</span></span><br><span class="line">            ans |= shift; <span class="comment">//將bit用or組起來</span></span><br><span class="line">        &#125;</span><br><span class="line">        shift &lt;&lt;= <span class="number">1</span>; <span class="comment">//左移換檢查下一個bit</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>第一個for為常數時間O(32) &#x3D; O(1)，第二個為遍歷vector nums，所以O(1) * O(n) &#x3D; O(n)。</li>
</ul>
<h2 id="Dynamic-Programming-相關問題"><a href="#Dynamic-Programming-相關問題" class="headerlink" title="Dynamic Programming 相關問題"></a>Dynamic Programming 相關問題</h2><h3 id="Q62"><a href="#Q62" class="headerlink" title="Q62"></a>Q62</h3><ul>
<li><font color="red"> 題目：</font>給兩個int，分別代表長(n)和寬(m)，從左上角走到右下角，途中只能往右或往下的方法有幾種<br><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths/">原題目連結</a><br></li>
<li><font color="red">範例：</font><br></li>
</ul>
<ol>
<li><br>
<img src="/2022/11/02/leetcode-Experience/leet_62.jpg" class="" title="leetcode 463 image">
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: m = 3, n = 7</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure></li>
<li><br>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: m = 3, n = 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Down -&gt; Down</span><br><span class="line">2. Down -&gt; Down -&gt; Right</span><br><span class="line">3. Down -&gt; Right -&gt; Down</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><font color="red">想法：</font><br>1.將每個方向(R or D)想像成必須組合他們已到達目的地，如：RRRDD(m&#x3D;3,n&#x3D;4)，他就是5!&#x2F;3!2!，從前者公式可以看出其為：(n*(n+1)<em>…</em>(n+m-2)) &#x2F; (1*…*(m-1))。<br>2.其實這是一題DP的題目，他可以從計算每格的步數來算出最後到達目的地的步數，但這裡是用較快的數學方式寫法。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">leetcode_62::uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> molecular = m - <span class="number">1</span>; <span class="comment">//(分子)</span></span><br><span class="line">    <span class="type">int</span> denominator = n - <span class="number">1</span>; <span class="comment">//(分母)</span></span><br><span class="line">    <span class="type">double</span> sum = <span class="number">1.0</span>; <span class="comment">//avoid have double like = 3/2 in operation</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= molecular; i++) &#123;</span><br><span class="line">        sum = sum * (denominator + i) / i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color="red">時間複雜度：</font>走一個寬度或長度，故O(n-1) or O(m-1)。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://WadeWei0307.github.io">Wade Kao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://wadewei0307.github.io/2022/11/02/leetcode-Experience/">https://wadewei0307.github.io/2022/11/02/leetcode-Experience/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/image/leetcode-Experience/leetcode_coverImg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/30/Drawing-structure-of-tree-using-Cplusplus/" title="Drawing structure of tree using C++"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Drawing structure of tree using C++</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/11/project-hexo-blog/" title="第一次架設個人網站(部落格)就上手 (Hexo + GitHub Pages)"><img class="cover" src="https://augustushsu.github.io/uploads/hexo-cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">第一次架設個人網站(部落格)就上手 (Hexo + GitHub Pages)</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/image/config.butterfly/Apple_logo_black.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wade Kao</div><div class="author-info__description">臺灣科技大學 - 資工碩士<br>Teradyne - Field Application Engineer</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Easy-Part"><span class="toc-number">1.</span> <span class="toc-text">Easy Part</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-%E7%9B%B8%E9%97%9C%E5%95%8F%E9%A1%8C"><span class="toc-number">1.1.</span> <span class="toc-text">Array 相關問題</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1"><span class="toc-number">1.1.1.</span> <span class="toc-text">Q1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q26"><span class="toc-number">1.1.2.</span> <span class="toc-text">Q26</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q27"><span class="toc-number">1.1.3.</span> <span class="toc-text">Q27</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q35"><span class="toc-number">1.1.4.</span> <span class="toc-text">Q35</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q66"><span class="toc-number">1.1.5.</span> <span class="toc-text">Q66</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q88"><span class="toc-number">1.1.6.</span> <span class="toc-text">Q88</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q108"><span class="toc-number">1.1.7.</span> <span class="toc-text">Q108</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q118"><span class="toc-number">1.1.8.</span> <span class="toc-text">Q118</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q119"><span class="toc-number">1.1.9.</span> <span class="toc-text">Q119</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q121"><span class="toc-number">1.1.10.</span> <span class="toc-text">Q121</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q136"><span class="toc-number">1.1.11.</span> <span class="toc-text">Q136</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q169"><span class="toc-number">1.1.12.</span> <span class="toc-text">Q169</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q217"><span class="toc-number">1.1.13.</span> <span class="toc-text">Q217</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q219"><span class="toc-number">1.1.14.</span> <span class="toc-text">Q219</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q228"><span class="toc-number">1.1.15.</span> <span class="toc-text">Q228</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q268"><span class="toc-number">1.1.16.</span> <span class="toc-text">Q268</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q283"><span class="toc-number">1.1.17.</span> <span class="toc-text">Q283</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q303"><span class="toc-number">1.1.18.</span> <span class="toc-text">Q303</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q349"><span class="toc-number">1.1.19.</span> <span class="toc-text">Q349</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q350"><span class="toc-number">1.1.20.</span> <span class="toc-text">Q350</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q448"><span class="toc-number">1.1.21.</span> <span class="toc-text">Q448</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q463"><span class="toc-number">1.1.22.</span> <span class="toc-text">Q463</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Medium-Part"><span class="toc-number">2.</span> <span class="toc-text">Medium Part</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-%E7%9B%B8%E9%97%9C%E5%95%8F%E9%A1%8C-1"><span class="toc-number">2.1.</span> <span class="toc-text">Array 相關問題</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q11"><span class="toc-number">2.1.1.</span> <span class="toc-text">Q11</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q49"><span class="toc-number">2.1.2.</span> <span class="toc-text">Q49</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q122"><span class="toc-number">2.1.3.</span> <span class="toc-text">Q122</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q137"><span class="toc-number">2.1.4.</span> <span class="toc-text">Q137</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dynamic-Programming-%E7%9B%B8%E9%97%9C%E5%95%8F%E9%A1%8C"><span class="toc-number">2.2.</span> <span class="toc-text">Dynamic Programming 相關問題</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q62"><span class="toc-number">2.2.1.</span> <span class="toc-text">Q62</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/30/Drawing-structure-of-tree-using-Cplusplus/" title="Drawing structure of tree using C++">Drawing structure of tree using C++</a><time datetime="2023-03-29T22:38:41.000Z" title="Created 2023-03-29 22:38:41">2023-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/02/leetcode-Experience/" title="leetcode Experience"><img src="/image/leetcode-Experience/leetcode_coverImg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="leetcode Experience"/></a><div class="content"><a class="title" href="/2022/11/02/leetcode-Experience/" title="leetcode Experience">leetcode Experience</a><time datetime="2022-11-01T19:18:00.000Z" title="Created 2022-11-01 19:18:00">2022-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/11/project-hexo-blog/" title="第一次架設個人網站(部落格)就上手 (Hexo + GitHub Pages)"><img src="https://augustushsu.github.io/uploads/hexo-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第一次架設個人網站(部落格)就上手 (Hexo + GitHub Pages)"/></a><div class="content"><a class="title" href="/2022/10/11/project-hexo-blog/" title="第一次架設個人網站(部落格)就上手 (Hexo + GitHub Pages)">第一次架設個人網站(部落格)就上手 (Hexo + GitHub Pages)</a><time datetime="2022-10-11T14:00:00.000Z" title="Created 2022-10-11 14:00:00">2022-10-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Wade Kao</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>